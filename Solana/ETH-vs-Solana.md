
- EVM（以太坊系）和 Solana 的核心交互与开发差异压

# 一句话心智模型

* **EVM**：单线程、共享全局状态的“对象系统”。每个合约自带代码和私有存储，用 `CALL` 串行交互，靠 **gas** 计量。
* **Solana**：账户即数据库行，**代码账户(Program)** 与 **数据账户(Account)** 分离；交易显式声明要读写的账户，Runtime 以 **账户锁** 做并行调度，靠 **Compute Units + 内存/账户大小** 计量。

# 关键差异对照

| 维度       | EVM（以太坊/兼容链）                                           | Solana                                                              |
| -------- | ------------------------------------------------------ | ------------------------------------------------------------------- |
| 账户/状态模型  | **Account Model**：EOA & 合约账户，每个合约自带存储（映射到 Merkle Trie） | **Program + Data Accounts**：代码与数据分离；数据账户像记录，按 owner(程序)管理           |
| 交互原语     | `CALL/DELEGATECALL/STATICCALL`，可链式/深层嵌套                | **CPI（Cross-Program Invocation）**，必须在交易里预先声明要用到的账户集合                |
| 并行性      | **基本串行**（一次交易内按指令顺序执行；全网打包也以串行为主）                      | **并行执行**：按账户读写集锁冲突拆分，无冲突可并行                                         |
| 可重入风险    | **有**（典型重入攻击场景；需 checks-effects-interactions/重入锁）      | **弱化**（账户锁与借用规则让同一数据账户难以被并发重入篡改，但仍要防逻辑级递归错误）                        |
| 资源计量     | **Gas**（计算+存储+带宽统一计费）                                  | **Compute Units (CU)** + 账户大小/内存/写账本成本分项限制                          |
| 费用与优先级   | 基础费+小费（EIP-1559）；以 gas price 竞价                        | 基于 CU/优先费（priority fee）；对热点账户会更贵/更易拥堵                               |
| 存储成本     | 永久存储一次性付费（有“燃烧/退款”规则；无租金）                              | **租金/最低余额**（Rent Exemption）：数据账户通常要保持最小余额免租                         |
| 地址/签名    | 地址 20 bytes，主流 **secp256k1**；合约地址可 CREATE/CREATE2      | 公钥 32 bytes，主流 **ed25519**；PDA（Program Derived Address）无私钥、由程序+种子推导 |
| 非ce/顺序控制 | 每个 EOA 线性 **nonce** 抗重放                                | **近期块哈希/最近区块高度** + 指令顺序；无 EOA nonce，依赖交易级去重策略                       |
| 语言/ABI   | Solidity/Vyper；**ABI 固定**（动态/静态类型编码）                   | Rust（主流）/C/Move(实验)；**无统一 ABI**，常自定义 Borsh/anchor 等序列化              |
| 事件日志     | `LOG*` 事件（不可被链上读取，主要供 off-chain 索引）                    | 程序日志/自定义事件；依靠交易元数据与索引服务（如 geyser/程序日志）                              |
| 可组合性     | 高（DeFi 乐高通过 `CALL` 串接）但受**串行与重入**约束                    | 高（CPI + 账户声明）且可并行，但受**账户列表长度/交易大小**约束                               |
| 升级模式     | 代理合约/不可变合约（UUPS/Transparent Proxy）                     | **可升级程序**（BPF Loader Upgradeable）或冻结不可升级；数据迁移需显式处理                  |
| 随机性      | 需 VRF/预言机；链上自身不可用                                      | 同样需外部随机源/预言机（Sysvar 不提供强随机）                                         |
| 观察性/调试   | EVM trace、revert reason、事件                             | 确定性日志、CU 消耗计数、账户快照，需熟悉 tx 模拟与 CU 预算                                 |

# 交互与工程落地差异（你可以这样答）

1. **“为什么 Solana 能并行、EVM 不行？”**

* EVM 交易执行时**不知道**会读写哪些存储槽 → 只能串行防冲突。
* Solana 在交易里**提前声明账户读写集**，Runtime 能对互不冲突的交易分片并行调度。

2. **“跨合约调用有什么不同？”**

* EVM：`CALL` 像函数栈，一次性把 `msg.sender/msg.value`、内存传过去；**重入**需防。
* Solana：**CPI** 要把用到的账户**显式**传给对方程序，权限靠账户 owner/签名/PDA 校验；**账户即权限界面**。

3. **“存储与成本怎么设计更优？”**

* EVM：少写存、多用事件、考虑位压缩/映射；注意冷热 SLOAD 成本与 refund 变更历史。
* Solana：**数据拆分多账户**、尽量保持 rent-exempt；热读写账户可能成瓶颈，要做 **账户分片/按用户维度隔离**。

4. **“可升级与可维护？”**

* EVM：代理 + 初始化函数；要防实现逻辑替换带来的存储槽错配。
* Solana：程序可升级需权力分离（升级权限托管/冻结）；数据迁移通过新版本程序逐步迁移账户。

# 从 EVM 迁移到 Solana 的常见坑

* **忘记显式传账户**：任何要读写的账户都必须在交易中列出，否则 CPI 失败。
* **把“合约存储”当成单体大对象**：在 Solana 应按用户/市场/池子拆成多账户，减少锁冲突。
* **权限模型错位**：不要用“全局 owner 变量”思路；用 **PDA + seeds + signer** 做细粒度授权。
* **交易/指令过大**：序列化结构要紧凑，必要时拆多条指令/多笔交易流水线执行。
* **CU 预算不足**：复杂聚合要么优化算法/减少 CPI 次数，要么提高优先费和 CU 上限。

# 什么时候选谁（面试给判断准则）

* **高并发、低延迟、订单簿/撮合/游戏内态更新** → 倾向 **Solana**（账户并行 + 低确认延迟）。
* **广泛的 EVM 生态复用、合规稳定 DeFi 乐高、跨链兼容** → 倾向 **EVM**（工具链成熟、资产网络效应强）。
* **复杂不可变金融合约、审计与长尾开发者支持** → **EVM** 优势明显。
* **需要把状态按用户分片、天然抗热点** → **Solana** 设计更贴合。

# 代码与调用视角的“翻译表”

* EVM `mapping(address => Position)`
  → Solana 拆成 `PositionAccount{owner=PDA(user)}`，每个用户一条数据账户；用 PDA seeds 保证唯一性与可验证性。
* EVM `call(other, data)`
  → Solana `invoke_signed(program_id, &[accounts...], &[seeds...])`，显式传账户 + 可选 PDA 签名。
* EVM 防重入 `nonReentrant`
  → Solana 通过**写锁**和账户粒度设计规避同区块并发写；仍需防“逻辑级”递归/重入型漏洞。
